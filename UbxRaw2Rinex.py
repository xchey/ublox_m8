"""
# Author: Chey
# -*- coding: utf-8 -*-
# @Time     : 7/15/2018, 1:38 PM
# @Author   : Chey
# @Email    : cheyu856@gmail.com
# @File     : UbxRaw2Rinex.py
# @Software : PyCharm
"""
import sys
from struct import unpack
from datetime import datetime, timedelta


# origin of the GPS time scale
GPSTIME = datetime(1980, 1, 6)

first_epoch_obs = None
rinex_batch_obs = None
first_epoch_eph = None
rinex_batch_eph = None

map_gnssid = {
    0 : 'G',    1 : 'S',
    2 : 'E',    3 : 'C',
    4 : 'I',    5 : 'Q',
    6 : 'R'
}


def gpstime_to_epoch(week, sow):
    """
    Converts from full cycle GPS time (week and seconds) to date and time

    """
    epoch = GPSTIME + timedelta(weeks=week, seconds=sow)

    return epoch


def check_rinex_field(name, value, size):
    """
    Checks if the field is of proper length and if not, it issues a
    warning message and returns a sanitized (cropeed) version of the
    field
    """

    if value is None:
        return "UNKN"

    if (len(value) > size):
        sys.stderr.write(
            "The '{0}' field [ {1} ] is too long [ {2} ]. Cropping to {3} characters\n".format(name, value, len(value),
                                                                                               size))

        return value[0:size]

    return value

def rinex3_nav_header(runby):
    """
    Rinex3 navigation header
    """
    VERSION = 3.02
    TYPE = 'OBSERVATION DATA'
    SATSYS = 'M: Mixed'
    # Version line
    h = "{0:9.2f}           {1:<20}{2:<20}RINEX VERSION / TYPE\n".format(VERSION, TYPE, SATSYS)

    # Pgm line
    PGM = 'ANDROID_RINEX'
    datestr = datetime.now().strftime("%Y%m%d %H%M%S")

    runby = check_rinex_field('RUNBY', runby, 20)
    h += "{0:<20}{1:<20}{2:<15} UTC PGM / RUN BY / DATE\n".format(PGM, runby, datestr)

    # Additional comment line for the program
    h += "{0:<60}COMMENT\n".format("*******************************************************")
    h += "{0:<60}COMMENT\n".format("Generated by Python ublox decoder script")
    h += "{0:<60}COMMENT\n".format("For doubts or inquiries, just put up your issues")
    h += "{0:<60}COMMENT\n".format("*******************************************************")
    h += "{0:<60}END OF HEADER\n".format(" ")

    return h

def rinex3_header(runby=None, marker=None, observer=None, agency=None, receiver=None, rxtype=None,
                  version='Android OS >7.0', antenna=None, anttype='internal', approx_position=[0, 0, 0],
                  antenna_hen=[0.0, 0.0, 0.0]):
    """
    Rinex3 observation header
    """
    VERSION = 3.02
    TYPE = 'OBSERVATION DATA'
    SATSYS = 'M: Mixed'
    # Version line
    h = "{0:9.2f}           {1:<20}{2:<20}RINEX VERSION / TYPE\n".format(VERSION, TYPE, SATSYS)

    # Pgm line
    PGM = 'GNSS Rinex'
    datestr = datetime.now().strftime("%Y%m%d %H%M%S")

    runby = check_rinex_field('RUNBY', runby, 20)
    h += "{0:<20}{1:<20}{2:<15} UTC PGM / RUN BY / DATE\n".format(PGM, runby, datestr)

    # Additional comment line for the program
    h += "{0:<60}COMMENT\n".format("************************************************************")
    h += "{0:<60}COMMENT\n".format("This file is generated by Python ublox decoder script. ")
    h += "{0:<60}COMMENT\n".format("************************************************************")

    # Marker name
    marker = check_rinex_field('MARKER NAME', marker, 60)
    h += "{0:<60}MARKER NAME\n".format(marker if marker is not None else " ")

    # maker number
    h += "{0:<60}MARKER NUMBER\n".format(" ")

    # maker type
    h += "{0:<60}MARKER TYPE\n".format(" ")

    # Observer and agency
    observer = check_rinex_field('OBSERVER', observer, 20)
    agency = check_rinex_field('AGENCY', agency, 40)
    h += "{0:<20}{1:<40}OBSERVER / AGENCY\n".format(observer, agency)

    # Receiver line
    receiver = check_rinex_field('RECEIVER NUMBER', receiver, 20)
    rxtype = check_rinex_field('RECEIVER TYPE', rxtype, 20)
    version = check_rinex_field('RECEIVER VERSION', version, 20)
    h += "{0:<20}{1:<20}{2:<20}REC # / TYPE / VERS\n".format(receiver, rxtype, version)

    # Antenna type
    antenna = check_rinex_field('ANTENNA NUMBER', antenna, 20)
    anttype = check_rinex_field('ANTENNA TYPE', anttype, 40)
    h += "{0:<20}{1:<40}ANT # / TYPE\n".format(antenna, anttype)

    # Approximate position
    h += "{0:14.4f}{1:14.4f}{2:14.4f}                  APPROX POSITION XYZ\n".format(*(approx_position))

    # Antenna offset
    h += "{0:14.4f}{1:14.4f}{2:14.4f}                  ANTENNA: DELTA H/E/N\n".format(*(antenna_hen))

    # Observables
    h += "G    4 C1C L1C D1C S1C                                      SYS / # / OBS TYPES\n"
    h += "R    4 C1C L1C D1C S1C                                      SYS / # / OBS TYPES\n"
    h += "E    4 C1B L1B D1B S1B                                      SYS / # / OBS TYPES\n"
    h += "C    4 C1I L1I D1I S1I                                      SYS / # / OBS TYPES\n"
    h += "J    4 C1C L1C D1C S1C                                      SYS / # / OBS TYPES\n"
    return h


def end_header(first_epoch):

    h = first_epoch.strftime("  %Y    %m    %d    %H    %M    %S.%f     GPS         TIME OF FIRST OBS\n").\
        replace(' 0', '  ')

    h += "{0:<60}END OF HEADER\n".format(" ")

    return h

class RinexBatch:
    """
    Class that stores a Batch of measurements corresponding to the same epoch
    """

    def __init__(self, epoch):
        """
        Sets (or resets) the class
        """

        self.__clear()

        self.epoch = epoch

    def add(self, gnssid, svid, c1, s1, l1, d1, lli):
        """
        Add measurement to a batch

        - C/A needs to be specified in meters
        - SNR must be specified as dB-Hz
        - L1 phase, if provided, needs to be specified in cycles
        - D1 doppler, expressed in Hz and positive if satellite is approaching,
          which is opposite of Android API.
        """

        self.gnssid.append(gnssid)
        self.svids.append(svid)
        self.c1.append(c1)
        self.s1.append(s1)
        self.l1.append(l1)
        self.d1.append(d1)
        self.lli.append(lli)

        return

    def print(self):
        """
        Prints batch.

        It generates a string with the batch as a RINEX epoch.

        After printing the data, the method clears the data

        There have been some cases where the epoch in the smartphones are
        repeated, therefore, this routine checks if there are repeated entries.
        In this case it skips all the epoch altogether.
        """

        # Check for repeated emtries. In this case skip
        for sat in self.svids:
            if self.svids.count(sat) > 1:
                sys.stderr.write(self.epoch.strftime("Detected repeated entries in epoch "
                                                     "[ %Y-%m-%d %H:%M:%S.%f ]. Skipping\n"))
                return ""

        b = self.epoch.strftime(" %y %m %d %H %M %S.%f   0" + "{0:3d}".format(len(self.svids)))
        data = ""

        for i in range(len(self.svids)):
            # Add continuation line for number of satellites if needed
            if i > 0 and i % 12 == 0:
                b += "\n{0:32}".format(" ")
            b += self.svids[i]
            data += "{0:14.3f}{1:14.3f}{2:14.3f}{3:14.3f}\n".format(self.c1[i], self.s1[i], self.l1[i],
                                                                          self.d1[i])

        return b + "\n" + data

    def print3(self):
        """
        Prints batch.

        It generates a string with the batch as a RINEX epoch.

        After printing the data, the method clears the data

        There have been some cases where the epoch in the smartphones are
        repeated, therefore, this routine checks if there are repeated entries.
        In this case it skips all the epoch altogether.
        """

        # Check for repeated emtries. In this case skip
        if len(self.gnssid) < 2:
            for sat in self.svids:
                if self.svids.count(sat) > 1:
                    sys.stderr.write(
                        self.epoch.strftime("Detected repeated entries in epoch [ %Y-%m-%d %H:%M:%S.%f ]. Skipping\n"))
                    return ""

        b = '> ' + self.epoch.strftime("%Y %m %d %H %M %S.%f").replace(' 0', '  ') + "   0" + \
            "{0:3d}".format(len(self.svids))

        data = ""

        for i in range(len(self.svids)):
            # Add continuation line for number of satellites if needed
            # if i > 0 and i % 12 == 0:
            #     b += "\n{0:32}".format(" ")
            # b += self.svids[i]
            data += "{0:1}{1:2}{2:14.3f}{3:14.3f}{4:1}{5:14.3f}{6:14.3f}\n".format(self.gnssid[i],
                                                                self.svids[i], self.c1[i], self.l1[i],
                                                                self.lli[i] if self.lli[i] == 1 else ' ',
                                                                self.d1[i], self.s1[i])

        return b + "\n" + data

    def __clear(self):
        """
        Clear the data stored in the object
        """

        self.epoch = None

        # List of gnss id of with respect to each satellites
        self.gnssid = []

        # List of satellite PRN numbers (identifiers)
        self.svids = []

        # List of code ranges
        self.c1 = []

        # List of carrier phases
        self.l1 = []

        # List of C/N0
        self.s1 = []

        # List of C/N0
        self.d1 = []

        # List of lli
        self.lli = []


def to_obs(fd, obs):
    '''
     ublox raw data to observations
    '''
    global first_epoch_obs, rinex_batch_obs
    for i in range(0, obs.numMeas):
        meas = obs.__getattribute__('meas' + str(i))
        # Convert the epoch to Python's buiit-in datetime class
        epoch = gpstime_to_epoch(obs.week, obs.rcvTow)

        # Check for first epoch, that will be used to end the header (to
        # print the compulsory TIME OF FIRST OBS field)
        if first_epoch_obs is None:
            fd.write(end_header(epoch))
            first_epoch_obs = False

        # Check if we need to create a new batch
        if rinex_batch_obs is None:
            rinex_batch_obs = RinexBatch(epoch)
        elif rinex_batch_obs.epoch != epoch:
            fd.write(rinex_batch_obs.print3())
            rinex_batch_obs = RinexBatch(epoch)
        # If we reached this point it means that all went well. Therefore
        # proceed to store the measurements
        rinex_batch_obs.add(map_gnssid[meas.gnssId], meas.svId, meas.prMes, meas.cno, meas.cpMes, meas.doMes, 0)


def to_eph(fd, raw):
    '''
    ublox raw data to ephemeris
    '''
    global first_epoch_eph, rinex_batch_eph, eph
    #TODO: decode ublox ephemeris



